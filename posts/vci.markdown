---
title: Voice Compression Identification
author: Wesley Tanner
date: 2014-06-02
---

This is a proof-of-concept tool used to identify the compression algorithm(s) used in a \"black box\" voice audio paths. That is, it will determine the type of voice compression used over an unknown digital voice channel. This initial version is designed to identify GSM voice compression (Adaptive Multi-Rate, or AMR), but could easily be extended to other algorithms.

The tool accomplishes this goal using a machine-learning classifier, specifically a support vector machine. Through the technique and testing described below, it achieves a 99.8% accuracy.

## Motivation

I was in the process of using a cellular voice network to conduct some tests, when I discovered I was not getting the results I expected. I then realized I had no way of knowing which voice compression algorithm was used by which carrier, and during which calls. This information is not readily available on a per-call basis. Further, the rate can be changed during the call based on channel conditions. Thus, I had no way to control for this variable in over-the-air testing.

## Technical details

The tool uses a multi-class support vector machine (SVM), with a linear kernel, to discriminate between six distinct voice compression pathways:

| Mode        | Rate (kbps) |
|-------------|-------------|
| PASSTHROUGH | 64          |
| AMR         | 12.2        |
| AMR102      | 10.2        |
| AMR795      | 7.95        |
| AMR67       | 6.7         |
| AMR59       | 5.9         |

The feature vector is length 16000, and represents 2 seconds of normalized audio samples scaled between -1 and 1, sampled at 8 kHz. The training and test vectors are generated by sending a 16000 sample sound clip through each of the compression algorithms several hundred times. To account for unknown channel conditions that may affect the output of the voice compression algorithm, the following channel effects were added to each training and test feature vector:

- Random delay, uniformly distributed from 0-5 s.
- Additive white gaussian noise (AWGN) with a signal-to-noise-ratio of 30dB.
- Random amplitude scaling, uniformly distributed between 50-100% full-scale \(3dB variation\).

Using these parameters, I obtain a prediction accuracy of 99.8%. I used libsvm defaults and have done no further tweaking of the model parameters.

## Usage

The tool requires training the support vector machine before it can attempt to identify an input sound file from an unknown voice channel. A short (few seconds) voice clip must be provided to generate the training and test vectors. The tool will crop it to 2 seconds and scale during preprocessing. A sample file is included, but there are many voice test wav files online if an alterate is desired. It should be voice, single channel (mono) and sampled at 8 kHz. GSM audio codecs expect 16 bit samples, with the 13 significat bits actually used.

~~~bash
octave "gen_training.m"
~~~

This generates two directories, \"test\" and \"training\", and fills these with feature vectors \(see Technical details section\).

### Train the SVM classifier

~~~bash
vci.py -t -i "train.wav" -o "class.pkl"
~~~

This will fit the \"training\" feature vectors and determine the support vectors. The \"test\" feature vectors are then used to score the accuracy of the compression algorithm classifications \(between 0 and 1\). The classifier is saved to the file \"class.pkl\" as a serialized Python object.

### Identification

~~~bash
vci.py -i "class.pkl" -p "./test/AMR/1.wav"
~~~

The output is the identified compression algorithm of the provided wav sample, using the trained classifier stored in \"class.pkl\". Note that the input wav file must be the same length as the training vectors, e\.g\. 16000 samples. This means it must have already been correlated or preprocessed in some way to remove any delay.

## Source

The source code is located [here](https://github.com/wtanner/vci).
